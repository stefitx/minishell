
ğŸšğŸ¢MINISHELL PROJECT MANAGEMENTğŸŒğŸ£

shortkingğŸ‘‘$ supremacy

emoji :

- ğŸŒ¸ = task finished by Stefi;
- ğŸ‘©ğŸ»â€ğŸ’» = task in progress by Stefi;
- ğŸ’ = task will be done by Stefi;

-  ğŸ¯ = task finished by Pablo;
-  âš”ï¸ = task in progress by Pablo;
-  ğŸ”« = task will be done by Pablo;

--------------------------------------------------------------------------------------------------------------------

ğŸ’- working history
{
	asdfghjkl, i would suppose it has to do with having a log of all commands used?
}

ğŸ¯ğŸŒ¸- command parsing and execution
{
	- must use readline and affiliated functions to read user input;
	- must parse input char by char, then split it accordingly;
		*** the split must handle ' (single quotes) and " (double quotes) ***
	ğŸŒ¸- must then execute the parsed commands by executing built-ins or external programs
}

ğŸ‘©ğŸ»â€ğŸ’»- built-ins
{
	- echo -n = suppress the newline added by the echo command;
	- cd = change directory with either a relative or an absolute path;
	- pwd = print working directory (prints the absolute path to the diirectory we are in);
	- export = shows set environment variables;
	- env = displays the current environment;
	- exit = exits the shell;
	- unset
}

ğŸŒ¸- redirections and pipes
{
	- < = takes input from a file;
	- > = writes output to a file;
	- >> = appends output to a file;
	- >> = has to be given a delimiter, reads stdin until delimiter is seen (here_doc bonus from pipex) DOES NOT UPDATE HISTORY;
	- | (Pipe) = connect output of one command to input of another;
}

ğŸ¯- environment variables and exit status
{
	- $ = when followed by variable name, expands said variable, executing the previous command (e.g. echo $PWD);
	ğŸ’- $? = holds the exit status of the last executed command, executes previous command on it (e.g. echo $?);
}

ğŸ¯- signal handling
{
	- ctrl-C = interrupts current process, displays a new line;
	- ctrl-D = exits the shell;
	- ctrl-\ = does nothing;
}

- bonus part
{
	- && = (logical AND) Usage: "command1 && command2" -> executes the second command only if the first command succeeds;
	- || = (logical OR) Usage: "command1 || command2" -> executes the second command only if the first command fails;
	- * (wildcards) = matches zero or more characters and can be used to match multiple files or directories with similar names
		- e.g.: "*.txt" matches all files with a .txt extension in the current directory, potentially applying commands to all of them
}

--------------------------------------------------------------------------------------------------------------------
